<?php
/**
 * AppResourceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client\Internetmarke
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Deutsche Post INTERNETMARKE API
 *
 * Division: Post & Parcel Germany<br /> The INTERNETMARKE is the online-postage for mail products of Deutsche Post AG.
 *
 * The version of the OpenAPI document: 1.23
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Internetmarke\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\Internetmarke\ApiException;
use OpenAPI\Client\Internetmarke\Configuration;
use OpenAPI\Client\Internetmarke\HeaderSelector;
use OpenAPI\Client\Internetmarke\ObjectSerializer;

/**
 * AppResourceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client\Internetmarke
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AppResourceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'chargeWallet' => [
            'application/json',
        ],
        'checkoutShoppingCartPDFApp' => [
            'application/json',
        ],
        'checkoutShoppingCartPNGApp' => [
            'application/json',
        ],
        'initShoppingCartApp' => [
            'application/json',
        ],
        'retoureVouchersApp' => [
            'application/json',
        ],
        'retrieveGalleryApp' => [
            'application/json',
        ],
        'retrieveRetoureStateApp' => [
            'application/json',
        ],
        'retrieveShoppingCartApp' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation chargeWallet
     *
     * Charge users wallet
     *
     * @param  int $amount The amount (positive integer as EUROCENT) to be charged for users wallet. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chargeWallet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function chargeWallet($amount, string $contentType = self::contentTypes['chargeWallet'][0])
    {
        list($response) = $this->chargeWalletWithHttpInfo($amount, $contentType);
        return $response;
    }

    /**
     * Operation chargeWalletWithHttpInfo
     *
     * Charge users wallet
     *
     * @param  int $amount The amount (positive integer as EUROCENT) to be charged for users wallet. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chargeWallet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function chargeWalletWithHttpInfo($amount, string $contentType = self::contentTypes['chargeWallet'][0])
    {
        $request = $this->chargeWalletRequest($amount, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chargeWalletAsync
     *
     * Charge users wallet
     *
     * @param  int $amount The amount (positive integer as EUROCENT) to be charged for users wallet. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chargeWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chargeWalletAsync($amount, string $contentType = self::contentTypes['chargeWallet'][0])
    {
        return $this->chargeWalletAsyncWithHttpInfo($amount, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chargeWalletAsyncWithHttpInfo
     *
     * Charge users wallet
     *
     * @param  int $amount The amount (positive integer as EUROCENT) to be charged for users wallet. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chargeWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chargeWalletAsyncWithHttpInfo($amount, string $contentType = self::contentTypes['chargeWallet'][0])
    {
        $returnType = '\OpenAPI\Client\Internetmarke\Model\ChargeWalletResponse';
        $request = $this->chargeWalletRequest($amount, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chargeWallet'
     *
     * @param  int $amount The amount (positive integer as EUROCENT) to be charged for users wallet. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chargeWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chargeWalletRequest($amount, string $contentType = self::contentTypes['chargeWallet'][0])
    {

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling chargeWallet'
            );
        }
        if ($amount < 1) {
            throw new \InvalidArgumentException('invalid value for "$amount" when calling AppResourceApi.chargeWallet, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/app/wallet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkoutShoppingCartPDFApp
     *
     * Checkouts ot the PDF shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPDFAppRequest $checkoutShoppingCartPDFAppRequest checkoutShoppingCartPDFAppRequest (required)
     * @param  bool $validate This request parameter enables the validate (preview) case.&lt;br/&gt;The response will contain the link to a preview image of an internet stamp in PDF format. A product code, a layout format and optionally a motif are transferred to the service. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code, print format, or theme ID is invalid, the response to the caller will contain appropriate information.   &lt;br/&gt;&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required and the request body has to be of the specified type (See &#x60;#/components/schemas/AppShoppingCartPreviewPDFRequest&#x60;). (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPDFApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function checkoutShoppingCartPDFApp($checkoutShoppingCartPDFAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPDFApp'][0])
    {
        list($response) = $this->checkoutShoppingCartPDFAppWithHttpInfo($checkoutShoppingCartPDFAppRequest, $validate, $finalize, $contentType);
        return $response;
    }

    /**
     * Operation checkoutShoppingCartPDFAppWithHttpInfo
     *
     * Checkouts ot the PDF shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPDFAppRequest $checkoutShoppingCartPDFAppRequest (required)
     * @param  bool $validate This request parameter enables the validate (preview) case.&lt;br/&gt;The response will contain the link to a preview image of an internet stamp in PDF format. A product code, a layout format and optionally a motif are transferred to the service. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code, print format, or theme ID is invalid, the response to the caller will contain appropriate information.   &lt;br/&gt;&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required and the request body has to be of the specified type (See &#x60;#/components/schemas/AppShoppingCartPreviewPDFRequest&#x60;). (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPDFApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkoutShoppingCartPDFAppWithHttpInfo($checkoutShoppingCartPDFAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPDFApp'][0])
    {
        $request = $this->checkoutShoppingCartPDFAppRequest($checkoutShoppingCartPDFAppRequest, $validate, $finalize, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkoutShoppingCartPDFAppAsync
     *
     * Checkouts ot the PDF shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPDFAppRequest $checkoutShoppingCartPDFAppRequest (required)
     * @param  bool $validate This request parameter enables the validate (preview) case.&lt;br/&gt;The response will contain the link to a preview image of an internet stamp in PDF format. A product code, a layout format and optionally a motif are transferred to the service. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code, print format, or theme ID is invalid, the response to the caller will contain appropriate information.   &lt;br/&gt;&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required and the request body has to be of the specified type (See &#x60;#/components/schemas/AppShoppingCartPreviewPDFRequest&#x60;). (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPDFApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutShoppingCartPDFAppAsync($checkoutShoppingCartPDFAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPDFApp'][0])
    {
        return $this->checkoutShoppingCartPDFAppAsyncWithHttpInfo($checkoutShoppingCartPDFAppRequest, $validate, $finalize, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkoutShoppingCartPDFAppAsyncWithHttpInfo
     *
     * Checkouts ot the PDF shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPDFAppRequest $checkoutShoppingCartPDFAppRequest (required)
     * @param  bool $validate This request parameter enables the validate (preview) case.&lt;br/&gt;The response will contain the link to a preview image of an internet stamp in PDF format. A product code, a layout format and optionally a motif are transferred to the service. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code, print format, or theme ID is invalid, the response to the caller will contain appropriate information.   &lt;br/&gt;&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required and the request body has to be of the specified type (See &#x60;#/components/schemas/AppShoppingCartPreviewPDFRequest&#x60;). (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPDFApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutShoppingCartPDFAppAsyncWithHttpInfo($checkoutShoppingCartPDFAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPDFApp'][0])
    {
        $returnType = 'object';
        $request = $this->checkoutShoppingCartPDFAppRequest($checkoutShoppingCartPDFAppRequest, $validate, $finalize, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkoutShoppingCartPDFApp'
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPDFAppRequest $checkoutShoppingCartPDFAppRequest (required)
     * @param  bool $validate This request parameter enables the validate (preview) case.&lt;br/&gt;The response will contain the link to a preview image of an internet stamp in PDF format. A product code, a layout format and optionally a motif are transferred to the service. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code, print format, or theme ID is invalid, the response to the caller will contain appropriate information.   &lt;br/&gt;&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required and the request body has to be of the specified type (See &#x60;#/components/schemas/AppShoppingCartPreviewPDFRequest&#x60;). (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPDFApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkoutShoppingCartPDFAppRequest($checkoutShoppingCartPDFAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPDFApp'][0])
    {

        // verify the required parameter 'checkoutShoppingCartPDFAppRequest' is set
        if ($checkoutShoppingCartPDFAppRequest === null || (is_array($checkoutShoppingCartPDFAppRequest) && count($checkoutShoppingCartPDFAppRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkoutShoppingCartPDFAppRequest when calling checkoutShoppingCartPDFApp'
            );
        }




        $resourcePath = '/app/shoppingcart/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $finalize,
            'finalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($checkoutShoppingCartPDFAppRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($checkoutShoppingCartPDFAppRequest));
            } else {
                $httpBody = $checkoutShoppingCartPDFAppRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkoutShoppingCartPNGApp
     *
     * Checkouts ot the PNG shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPNGAppRequest $checkoutShoppingCartPNGAppRequest checkoutShoppingCartPNGAppRequest (required)
     * @param  bool $validate The response will contain the link to a thumbnail image of an Internet brand in PNG format, which the third-party application must integrate accordingly. The print format is not relevant at this point. The service is given a product code, optionally a motif and a layout format. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code or theme ID is invalid, the response to the caller will contain appropriate information.&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required. (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPNGApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function checkoutShoppingCartPNGApp($checkoutShoppingCartPNGAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPNGApp'][0])
    {
        list($response) = $this->checkoutShoppingCartPNGAppWithHttpInfo($checkoutShoppingCartPNGAppRequest, $validate, $finalize, $contentType);
        return $response;
    }

    /**
     * Operation checkoutShoppingCartPNGAppWithHttpInfo
     *
     * Checkouts ot the PNG shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPNGAppRequest $checkoutShoppingCartPNGAppRequest (required)
     * @param  bool $validate The response will contain the link to a thumbnail image of an Internet brand in PNG format, which the third-party application must integrate accordingly. The print format is not relevant at this point. The service is given a product code, optionally a motif and a layout format. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code or theme ID is invalid, the response to the caller will contain appropriate information.&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required. (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPNGApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkoutShoppingCartPNGAppWithHttpInfo($checkoutShoppingCartPNGAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPNGApp'][0])
    {
        $request = $this->checkoutShoppingCartPNGAppRequest($checkoutShoppingCartPNGAppRequest, $validate, $finalize, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkoutShoppingCartPNGAppAsync
     *
     * Checkouts ot the PNG shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPNGAppRequest $checkoutShoppingCartPNGAppRequest (required)
     * @param  bool $validate The response will contain the link to a thumbnail image of an Internet brand in PNG format, which the third-party application must integrate accordingly. The print format is not relevant at this point. The service is given a product code, optionally a motif and a layout format. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code or theme ID is invalid, the response to the caller will contain appropriate information.&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required. (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPNGApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutShoppingCartPNGAppAsync($checkoutShoppingCartPNGAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPNGApp'][0])
    {
        return $this->checkoutShoppingCartPNGAppAsyncWithHttpInfo($checkoutShoppingCartPNGAppRequest, $validate, $finalize, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkoutShoppingCartPNGAppAsyncWithHttpInfo
     *
     * Checkouts ot the PNG shopping cart.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPNGAppRequest $checkoutShoppingCartPNGAppRequest (required)
     * @param  bool $validate The response will contain the link to a thumbnail image of an Internet brand in PNG format, which the third-party application must integrate accordingly. The print format is not relevant at this point. The service is given a product code, optionally a motif and a layout format. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code or theme ID is invalid, the response to the caller will contain appropriate information.&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required. (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPNGApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkoutShoppingCartPNGAppAsyncWithHttpInfo($checkoutShoppingCartPNGAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPNGApp'][0])
    {
        $returnType = 'object';
        $request = $this->checkoutShoppingCartPNGAppRequest($checkoutShoppingCartPNGAppRequest, $validate, $finalize, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkoutShoppingCartPNGApp'
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartPNGAppRequest $checkoutShoppingCartPNGAppRequest (required)
     * @param  bool $validate The response will contain the link to a thumbnail image of an Internet brand in PNG format, which the third-party application must integrate accordingly. The print format is not relevant at this point. The service is given a product code, optionally a motif and a layout format. This information is encoded in the link and evaluated by INTERNETMARKE when the preview image is rendered. If the product code or theme ID is invalid, the response to the caller will contain appropriate information.&lt;br/&gt; For the validate (preview) case the &#39;Authorization&#39; header is not required. (optional, default to false)
     * @param  bool $finalize This request parameter enables the direct finalization of the shopping cart and an extra finalization request is not required. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkoutShoppingCartPNGApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkoutShoppingCartPNGAppRequest($checkoutShoppingCartPNGAppRequest, $validate = false, $finalize = false, string $contentType = self::contentTypes['checkoutShoppingCartPNGApp'][0])
    {

        // verify the required parameter 'checkoutShoppingCartPNGAppRequest' is set
        if ($checkoutShoppingCartPNGAppRequest === null || (is_array($checkoutShoppingCartPNGAppRequest) && count($checkoutShoppingCartPNGAppRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkoutShoppingCartPNGAppRequest when calling checkoutShoppingCartPNGApp'
            );
        }




        $resourcePath = '/app/shoppingcart/png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $finalize,
            'finalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($checkoutShoppingCartPNGAppRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($checkoutShoppingCartPNGAppRequest));
            } else {
                $httpBody = $checkoutShoppingCartPNGAppRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initShoppingCartApp
     *
     * Initializes a shopping cart and returns the shopOrderId.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['initShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function initShoppingCartApp(string $contentType = self::contentTypes['initShoppingCartApp'][0])
    {
        list($response) = $this->initShoppingCartAppWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation initShoppingCartAppWithHttpInfo
     *
     * Initializes a shopping cart and returns the shopOrderId.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['initShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function initShoppingCartAppWithHttpInfo(string $contentType = self::contentTypes['initShoppingCartApp'][0])
    {
        $request = $this->initShoppingCartAppRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation initShoppingCartAppAsync
     *
     * Initializes a shopping cart and returns the shopOrderId.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['initShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initShoppingCartAppAsync(string $contentType = self::contentTypes['initShoppingCartApp'][0])
    {
        return $this->initShoppingCartAppAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initShoppingCartAppAsyncWithHttpInfo
     *
     * Initializes a shopping cart and returns the shopOrderId.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['initShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function initShoppingCartAppAsyncWithHttpInfo(string $contentType = self::contentTypes['initShoppingCartApp'][0])
    {
        $returnType = '\OpenAPI\Client\Internetmarke\Model\InitShoppingCartResponse';
        $request = $this->initShoppingCartAppRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initShoppingCartApp'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['initShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function initShoppingCartAppRequest(string $contentType = self::contentTypes['initShoppingCartApp'][0])
    {


        $resourcePath = '/app/shoppingcart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retoureVouchersApp
     *
     * Retoure vouchers For App.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\RetoureVouchersRequest $retoureVouchersRequest retoureVouchersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retoureVouchersApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function retoureVouchersApp($retoureVouchersRequest, string $contentType = self::contentTypes['retoureVouchersApp'][0])
    {
        list($response) = $this->retoureVouchersAppWithHttpInfo($retoureVouchersRequest, $contentType);
        return $response;
    }

    /**
     * Operation retoureVouchersAppWithHttpInfo
     *
     * Retoure vouchers For App.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\RetoureVouchersRequest $retoureVouchersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retoureVouchersApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function retoureVouchersAppWithHttpInfo($retoureVouchersRequest, string $contentType = self::contentTypes['retoureVouchersApp'][0])
    {
        $request = $this->retoureVouchersAppRequest($retoureVouchersRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retoureVouchersAppAsync
     *
     * Retoure vouchers For App.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\RetoureVouchersRequest $retoureVouchersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retoureVouchersApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retoureVouchersAppAsync($retoureVouchersRequest, string $contentType = self::contentTypes['retoureVouchersApp'][0])
    {
        return $this->retoureVouchersAppAsyncWithHttpInfo($retoureVouchersRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retoureVouchersAppAsyncWithHttpInfo
     *
     * Retoure vouchers For App.
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\RetoureVouchersRequest $retoureVouchersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retoureVouchersApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retoureVouchersAppAsyncWithHttpInfo($retoureVouchersRequest, string $contentType = self::contentTypes['retoureVouchersApp'][0])
    {
        $returnType = '\OpenAPI\Client\Internetmarke\Model\RetoureVouchersResponse';
        $request = $this->retoureVouchersAppRequest($retoureVouchersRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retoureVouchersApp'
     *
     * @param  \OpenAPI\Client\Internetmarke\Model\RetoureVouchersRequest $retoureVouchersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retoureVouchersApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retoureVouchersAppRequest($retoureVouchersRequest, string $contentType = self::contentTypes['retoureVouchersApp'][0])
    {

        // verify the required parameter 'retoureVouchersRequest' is set
        if ($retoureVouchersRequest === null || (is_array($retoureVouchersRequest) && count($retoureVouchersRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $retoureVouchersRequest when calling retoureVouchersApp'
            );
        }


        $resourcePath = '/app/retoure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($retoureVouchersRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($retoureVouchersRequest));
            } else {
                $httpBody = $retoureVouchersRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveGalleryApp
     *
     * Retrieve galleries.
     *
     * @param  string[] $types The type of the required gallery, can be specified as single or multiple. Only specified types will be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveGalleryApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function retrieveGalleryApp($types, string $contentType = self::contentTypes['retrieveGalleryApp'][0])
    {
        list($response) = $this->retrieveGalleryAppWithHttpInfo($types, $contentType);
        return $response;
    }

    /**
     * Operation retrieveGalleryAppWithHttpInfo
     *
     * Retrieve galleries.
     *
     * @param  string[] $types The type of the required gallery, can be specified as single or multiple. Only specified types will be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveGalleryApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveGalleryAppWithHttpInfo($types, string $contentType = self::contentTypes['retrieveGalleryApp'][0])
    {
        $request = $this->retrieveGalleryAppRequest($types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retrieveGalleryAppAsync
     *
     * Retrieve galleries.
     *
     * @param  string[] $types The type of the required gallery, can be specified as single or multiple. Only specified types will be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveGalleryApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveGalleryAppAsync($types, string $contentType = self::contentTypes['retrieveGalleryApp'][0])
    {
        return $this->retrieveGalleryAppAsyncWithHttpInfo($types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveGalleryAppAsyncWithHttpInfo
     *
     * Retrieve galleries.
     *
     * @param  string[] $types The type of the required gallery, can be specified as single or multiple. Only specified types will be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveGalleryApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveGalleryAppAsyncWithHttpInfo($types, string $contentType = self::contentTypes['retrieveGalleryApp'][0])
    {
        $returnType = '\OpenAPI\Client\Internetmarke\Model\RetrieveGalleryResponse';
        $request = $this->retrieveGalleryAppRequest($types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveGalleryApp'
     *
     * @param  string[] $types The type of the required gallery, can be specified as single or multiple. Only specified types will be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveGalleryApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retrieveGalleryAppRequest($types, string $contentType = self::contentTypes['retrieveGalleryApp'][0])
    {

        // verify the required parameter 'types' is set
        if ($types === null || (is_array($types) && count($types) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $types when calling retrieveGalleryApp'
            );
        }


        $resourcePath = '/app/gallery';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveRetoureStateApp
     *
     * Retrieve retoure state for App.
     *
     * @param  string $shopRetoureId The shopRetoureId was returned from the retoure Vouchers request. (optional)
     * @param  int $retoureTransactionId Internal transaction number under which the refund was booked in the PCF. (optional)
     * @param  \DateTime $startDate The start date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  \DateTime $endDate The end date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveRetoureStateApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function retrieveRetoureStateApp($shopRetoureId = null, $retoureTransactionId = null, $startDate = null, $endDate = null, string $contentType = self::contentTypes['retrieveRetoureStateApp'][0])
    {
        list($response) = $this->retrieveRetoureStateAppWithHttpInfo($shopRetoureId, $retoureTransactionId, $startDate, $endDate, $contentType);
        return $response;
    }

    /**
     * Operation retrieveRetoureStateAppWithHttpInfo
     *
     * Retrieve retoure state for App.
     *
     * @param  string $shopRetoureId The shopRetoureId was returned from the retoure Vouchers request. (optional)
     * @param  int $retoureTransactionId Internal transaction number under which the refund was booked in the PCF. (optional)
     * @param  \DateTime $startDate The start date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  \DateTime $endDate The end date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveRetoureStateApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveRetoureStateAppWithHttpInfo($shopRetoureId = null, $retoureTransactionId = null, $startDate = null, $endDate = null, string $contentType = self::contentTypes['retrieveRetoureStateApp'][0])
    {
        $request = $this->retrieveRetoureStateAppRequest($shopRetoureId, $retoureTransactionId, $startDate, $endDate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retrieveRetoureStateAppAsync
     *
     * Retrieve retoure state for App.
     *
     * @param  string $shopRetoureId The shopRetoureId was returned from the retoure Vouchers request. (optional)
     * @param  int $retoureTransactionId Internal transaction number under which the refund was booked in the PCF. (optional)
     * @param  \DateTime $startDate The start date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  \DateTime $endDate The end date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveRetoureStateApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveRetoureStateAppAsync($shopRetoureId = null, $retoureTransactionId = null, $startDate = null, $endDate = null, string $contentType = self::contentTypes['retrieveRetoureStateApp'][0])
    {
        return $this->retrieveRetoureStateAppAsyncWithHttpInfo($shopRetoureId, $retoureTransactionId, $startDate, $endDate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveRetoureStateAppAsyncWithHttpInfo
     *
     * Retrieve retoure state for App.
     *
     * @param  string $shopRetoureId The shopRetoureId was returned from the retoure Vouchers request. (optional)
     * @param  int $retoureTransactionId Internal transaction number under which the refund was booked in the PCF. (optional)
     * @param  \DateTime $startDate The start date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  \DateTime $endDate The end date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveRetoureStateApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveRetoureStateAppAsyncWithHttpInfo($shopRetoureId = null, $retoureTransactionId = null, $startDate = null, $endDate = null, string $contentType = self::contentTypes['retrieveRetoureStateApp'][0])
    {
        $returnType = '\OpenAPI\Client\Internetmarke\Model\RetrieveRetoureStateResponse';
        $request = $this->retrieveRetoureStateAppRequest($shopRetoureId, $retoureTransactionId, $startDate, $endDate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveRetoureStateApp'
     *
     * @param  string $shopRetoureId The shopRetoureId was returned from the retoure Vouchers request. (optional)
     * @param  int $retoureTransactionId Internal transaction number under which the refund was booked in the PCF. (optional)
     * @param  \DateTime $startDate The start date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  \DateTime $endDate The end date of the search. Expected format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveRetoureStateApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retrieveRetoureStateAppRequest($shopRetoureId = null, $retoureTransactionId = null, $startDate = null, $endDate = null, string $contentType = self::contentTypes['retrieveRetoureStateApp'][0])
    {






        $resourcePath = '/app/retoure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shopRetoureId,
            'shopRetoureId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $retoureTransactionId,
            'retoureTransactionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startDate,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endDate,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveShoppingCartApp
     *
     * Retrieves a shopping cart.
     *
     * @param  string $shopOrderId The shopOrderId was responsed within the response body of the checkout operation. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus
     */
    public function retrieveShoppingCartApp($shopOrderId, string $contentType = self::contentTypes['retrieveShoppingCartApp'][0])
    {
        list($response) = $this->retrieveShoppingCartAppWithHttpInfo($shopOrderId, $contentType);
        return $response;
    }

    /**
     * Operation retrieveShoppingCartAppWithHttpInfo
     *
     * Retrieves a shopping cart.
     *
     * @param  string $shopOrderId The shopOrderId was responsed within the response body of the checkout operation. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\Internetmarke\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error401Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\RequestStatus|\OpenAPI\Client\Internetmarke\Model\Error429Response|\OpenAPI\Client\Internetmarke\Model\RequestStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveShoppingCartAppWithHttpInfo($shopOrderId, string $contentType = self::contentTypes['retrieveShoppingCartApp'][0])
    {
        $request = $this->retrieveShoppingCartAppRequest($shopOrderId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error401Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\Error429Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\Error429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Internetmarke\Model\RequestStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Internetmarke\Model\RequestStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\Error429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Internetmarke\Model\RequestStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retrieveShoppingCartAppAsync
     *
     * Retrieves a shopping cart.
     *
     * @param  string $shopOrderId The shopOrderId was responsed within the response body of the checkout operation. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveShoppingCartAppAsync($shopOrderId, string $contentType = self::contentTypes['retrieveShoppingCartApp'][0])
    {
        return $this->retrieveShoppingCartAppAsyncWithHttpInfo($shopOrderId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveShoppingCartAppAsyncWithHttpInfo
     *
     * Retrieves a shopping cart.
     *
     * @param  string $shopOrderId The shopOrderId was responsed within the response body of the checkout operation. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveShoppingCartAppAsyncWithHttpInfo($shopOrderId, string $contentType = self::contentTypes['retrieveShoppingCartApp'][0])
    {
        $returnType = '\OpenAPI\Client\Internetmarke\Model\CheckoutShoppingCartAppResponse';
        $request = $this->retrieveShoppingCartAppRequest($shopOrderId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveShoppingCartApp'
     *
     * @param  string $shopOrderId The shopOrderId was responsed within the response body of the checkout operation. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveShoppingCartApp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retrieveShoppingCartAppRequest($shopOrderId, string $contentType = self::contentTypes['retrieveShoppingCartApp'][0])
    {

        // verify the required parameter 'shopOrderId' is set
        if ($shopOrderId === null || (is_array($shopOrderId) && count($shopOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shopOrderId when calling retrieveShoppingCartApp'
            );
        }
        if (strlen($shopOrderId) > 18) {
            throw new \InvalidArgumentException('invalid length for "$shopOrderId" when calling AppResourceApi.retrieveShoppingCartApp, must be smaller than or equal to 18.');
        }
        if (strlen($shopOrderId) < 1) {
            throw new \InvalidArgumentException('invalid length for "$shopOrderId" when calling AppResourceApi.retrieveShoppingCartApp, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/app/shoppingcart/{shopOrderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($shopOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'shopOrderId' . '}',
                ObjectSerializer::toPathValue($shopOrderId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
